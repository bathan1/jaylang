import{_ as i,c as a,o as e,ah as t}from"./chunks/framework.Cga242Po.js";const g=JSON.parse('{"title":"Erase types from Bluejay programs","description":"","frontmatter":{},"headers":[],"relativePath":"spec/type_erasure.md","filePath":"spec/type_erasure.md"}'),n={name:"spec/type_erasure.md"};function l(h,s,p,k,r,d){return e(),a("div",null,[...s[0]||(s[0]=[t(`<h1 id="erase-types-from-bluejay-programs" tabindex="-1">Erase types from Bluejay programs <a class="header-anchor" href="#erase-types-from-bluejay-programs" aria-label="Permalink to “Erase types from Bluejay programs”">​</a></h1><p>Bluejay programs are actually run (after the type-checking phase) in &quot;type erased&quot; mode. All types are sent to unusable unit values <code>()</code>, and type functions are consequently sent to functions that return <code>()</code>.</p><p>Type erasure defines the <em>meaning</em> of <em>running</em> a Bluejay program after the program has been type checked. The meaning of types in Bluejay are defined by their embeddings (see <code>embed.md</code>), and they do not have a semantics otherwise--hence we erase them.</p><p>Definitions:</p><ul><li>Angle brackets with pipes <code>&lt;| . |&gt; : Bluejay -&gt; TypeErased</code> is a mapping to erase types from Bluejay code.</li><li>Anything that is not explicitly mapped in this specification is implicitly mapped homomorphically; structure is preserved, and components are recursively mapped.</li></ul><h2 id="types" tabindex="-1">Types <a class="header-anchor" href="#types" aria-label="Permalink to “Types”">​</a></h2><p>All translations of types are the same: they are destroyed and sent to unit values.</p><p>The categorization here is just for simple organization.</p><h3 id="primitive-types" tabindex="-1">Primitive types <a class="header-anchor" href="#primitive-types" aria-label="Permalink to “Primitive types”">​</a></h3><div class="language-ocaml"><button title="Copy Code" class="copy"></button><span class="lang">ocaml</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;| </span><span style="--shiki-light:#D73A49;--shiki-light-text-decoration:underline;--shiki-dark:#F97583;--shiki-dark-text-decoration:underline;">type</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> |&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> int </span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">|&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bool </span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">|&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> top </span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">|&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bottom </span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">|&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> unit </span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">|&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ()</span></span></code></pre></div><h3 id="record-and-module-types" tabindex="-1">Record and module types <a class="header-anchor" href="#record-and-module-types" aria-label="Permalink to “Record and module types”">​</a></h3><div class="language-ocaml"><button title="Copy Code" class="copy"></button><span class="lang">ocaml</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;| { l_1 : tau_1 ; ... ; l_n : tau_n } |&gt; = ()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;| sig </span><span style="--shiki-light:#005CC5;--shiki-light-text-decoration:underline;--shiki-dark:#79B8FF;--shiki-dark-text-decoration:underline;">val</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> l_1</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tau_1 </span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">...</span><span style="--shiki-light:#005CC5;--shiki-light-text-decoration:underline;--shiki-dark:#79B8FF;--shiki-dark-text-decoration:underline;"> val</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> l_n</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tau_n end |&gt; = ()</span></span></code></pre></div><h3 id="function-types" tabindex="-1">Function types <a class="header-anchor" href="#function-types" aria-label="Permalink to “Function types”">​</a></h3><div class="language-ocaml"><button title="Copy Code" class="copy"></button><span class="lang">ocaml</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;| tau_1 -&gt; tau_2 |&gt; = ()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;| tau_1 --&gt; tau_2 |&gt; = ()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;| (x : tau_1) -&gt; tau_2 |&gt; = ()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;| (x : tau_1) --&gt; tau_2 |&gt; = ()</span></span></code></pre></div><h3 id="refinement-types" tabindex="-1">Refinement types <a class="header-anchor" href="#refinement-types" aria-label="Permalink to “Refinement types”">​</a></h3><div class="language-ocaml"><button title="Copy Code" class="copy"></button><span class="lang">ocaml</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;| { tau | e } |&gt; = ()</span></span></code></pre></div><h3 id="variant-and-function-intersection-types" tabindex="-1">Variant and function intersection types <a class="header-anchor" href="#variant-and-function-intersection-types" aria-label="Permalink to “Variant and function intersection types”">​</a></h3><div class="language-ocaml"><button title="Copy Code" class="copy"></button><span class="lang">ocaml</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;| \`V_1 of tau_1 | ... | \`V_n of tau_n |&gt; = ()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;| ((\`V_0 of tau_0) -&gt; tau_0&#39;) &amp; ... &amp; ((\`V_n of tau_n) -&gt; tau_n&#39;) |&gt; = ()</span></span></code></pre></div><h3 id="type-functions" tabindex="-1">Type functions <a class="header-anchor" href="#type-functions" aria-label="Permalink to “Type functions”">​</a></h3><p>Type functions need to accept parameters to preserve the semantics of their meaning. The parameters are discarded, and the type-erased version returns <code>()</code>.</p><div class="language-ocaml"><button title="Copy Code" class="copy"></button><span class="lang">ocaml</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;| list |&gt; = fun _ -&gt; ()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;| singlet |&gt; = fun _ -&gt; ()</span></span></code></pre></div><h2 id="recursive-types" tabindex="-1">Recursive types <a class="header-anchor" href="#recursive-types" aria-label="Permalink to “Recursive types”">​</a></h2><div class="language-ocaml"><button title="Copy Code" class="copy"></button><span class="lang">ocaml</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;| mu t. tau |&gt; = ()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;| mu t a_1 a_2 ... a_n. tau |&gt; = </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  fun _ _ ... _ -&gt; ()</span></span></code></pre></div><p>Notes:</p><ul><li>Without any parameters, a recursive type can just be <code>()</code>.</li><li>For <code>n</code> parameters on <code>t</code>, there are <code>n</code> ignored function parameters in the type-erased target.</li></ul><h2 id="let-expressions" tabindex="-1">Let expressions <a class="header-anchor" href="#let-expressions" aria-label="Permalink to “Let expressions”">​</a></h2><div class="language-ocaml"><button title="Copy Code" class="copy"></button><span class="lang">ocaml</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;| </span><span style="--shiki-light:#D73A49;--shiki-light-text-decoration:underline;--shiki-dark:#F97583;--shiki-dark-text-decoration:underline;">let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> x</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tau </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e in e&#39; |&gt; =</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-light-text-decoration:underline;--shiki-dark:#F97583;--shiki-dark-text-decoration:underline;">  let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> &lt;|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e </span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">|&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> in &lt;| e&#39; |&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;| </span><span style="--shiki-light:#D73A49;--shiki-light-text-decoration:underline;--shiki-dark:#F97583;--shiki-dark-text-decoration:underline;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (rec) </span><span style="--shiki-light:#005CC5;--shiki-light-text-decoration:underline;--shiki-dark:#79B8FF;--shiki-dark-text-decoration:underline;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> a_1</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> ...</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> a_n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#005CC5;--shiki-light-text-decoration:underline;--shiki-dark:#79B8FF;--shiki-dark-text-decoration:underline;">x_1</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tau_1) </span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-light-text-decoration:underline;--shiki-dark:#79B8FF;--shiki-dark-text-decoration:underline;">x_m</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tau_m) </span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tau </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">=</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    e</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   in</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   e&#39; |&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-light-text-decoration:underline;--shiki-dark:#F97583;--shiki-dark-text-decoration:underline;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (rec) </span><span style="--shiki-light:#005CC5;--shiki-light-text-decoration:underline;--shiki-dark:#79B8FF;--shiki-dark-text-decoration:underline;">f</span><span style="--shiki-light:#005CC5;--shiki-light-text-decoration:underline;--shiki-dark:#79B8FF;--shiki-dark-text-decoration:underline;"> a_1</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> ...</span><span style="--shiki-light:#005CC5;--shiki-light-text-decoration:underline;--shiki-dark:#79B8FF;--shiki-dark-text-decoration:underline;"> a_n</span><span style="--shiki-light:#005CC5;--shiki-light-text-decoration:underline;--shiki-dark:#79B8FF;--shiki-dark-text-decoration:underline;"> x_1</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> ...</span><span style="--shiki-light:#005CC5;--shiki-light-text-decoration:underline;--shiki-dark:#79B8FF;--shiki-dark-text-decoration:underline;"> x_m</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> =</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">    &lt;|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e </span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">|&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  in</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;| e&#39; |&gt;</span></span></code></pre></div><h2 id="statements" tabindex="-1">Statements <a class="header-anchor" href="#statements" aria-label="Permalink to “Statements”">​</a></h2><p>Statements are type erased correspondingly to let expressions.</p><h2 id="everything-else" tabindex="-1">Everything else <a class="header-anchor" href="#everything-else" aria-label="Permalink to “Everything else”">​</a></h2><p>Everything else is type erased homomorphically as stated above.</p><p>For example, with addition, type erasure is defined as follows.</p><div class="language-ocaml"><button title="Copy Code" class="copy"></button><span class="lang">ocaml</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;| e + e&#39; |&gt; =</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;| e |&gt; + &lt;| e&#39; |&gt;</span></span></code></pre></div>`,33)])])}const c=i(n,[["render",l]]);export{g as __pageData,c as default};
