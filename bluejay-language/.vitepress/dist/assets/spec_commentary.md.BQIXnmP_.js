import{_ as e,c as s,o as t,ah as a}from"./chunks/framework.Cga242Po.js";const c=JSON.parse('{"title":"Translation commentary","description":"","frontmatter":{},"headers":[],"relativePath":"spec/commentary.md","filePath":"spec/commentary.md"}'),n={name:"spec/commentary.md"};function h(l,i,r,o,k,d){return t(),s("div",null,[...i[0]||(i[0]=[a(`<h1 id="translation-commentary" tabindex="-1">Translation commentary <a class="header-anchor" href="#translation-commentary" aria-label="Permalink to “Translation commentary”">​</a></h1><p>We didn&#39;t just snap our fingers, and the translation specification popped into existence. No, we had to think and talk through a lot of the definitions. Here is a file containing some of that commentary, if it makes sense to keep around. Otherwise, the <code>desugar</code> and <code>embed</code> specifications are relatively to-the-point.</p><h2 id="_20-sided-die" tabindex="-1">20-sided die <a class="header-anchor" href="#_20-sided-die" aria-label="Permalink to “20-sided die”">​</a></h2><p>The &quot;20-sided die&quot; idea is to roll a die before we start evaluating the program, and the roll determines which checker we run; other types become only &quot;wrap&quot;, and the one we rolled gets a &quot;check&quot;. This way, we don&#39;t have to run all checkers beforehand (which may diverge) in order to check the statement at the end of the program.</p><p>But how do we handle types that are inside the body of let-expressions? For example:</p><div class="language-ocaml"><button title="Copy Code" class="copy"></button><span class="lang">ocaml</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-light-text-decoration:underline;--shiki-dark:#F97583;--shiki-dark-text-decoration:underline;">let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#005CC5;--shiki-light-text-decoration:underline;--shiki-dark:#79B8FF;--shiki-dark-text-decoration:underline;"> x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> =</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-light-text-decoration:underline;--shiki-dark:#F97583;--shiki-dark-text-decoration:underline;">  let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> g</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-light-text-decoration:underline;--shiki-dark:#79B8FF;--shiki-dark-text-decoration:underline;">y</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> int) </span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> int </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-light-text-decoration:underline;--shiki-dark:#F97583;--shiki-dark-text-decoration:underline;">in</span><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;"> (* only ever here after calling f *)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  x</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">in</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-light-text-decoration:underline;--shiki-dark:#F97583;--shiki-dark-text-decoration:underline;">let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> h</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-light-text-decoration:underline;--shiki-dark:#79B8FF;--shiki-dark-text-decoration:underline;">x</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> int) </span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> int </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">=</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-light-text-decoration:underline;--shiki-dark:#F97583;--shiki-dark-text-decoration:underline;">  let</span><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;"> _</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> f x </span><span style="--shiki-light:#D73A49;--shiki-light-text-decoration:underline;--shiki-dark:#F97583;--shiki-dark-text-decoration:underline;">in</span><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;"> (* pulls the check of g into here *)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  x</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">in</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">h</span></span></code></pre></div><p>Because of this example we cannot simply give a single rolled value to each checker--<code>g</code>&#39;s checker could never get run because it only gets run in sequence with <code>h</code>, which would have a different roll value. This is not an easy problem to solve, so we instead avoid it.</p><p>It&#39;s for this reason that Bluejay programs are a sequence of statements, where we only &quot;roll a die&quot; to decide which statement to check. All other typed let-expressions that are <strong>not</strong> statements always have their checkers turned on, and all &quot;non-rolled&quot; statements are only wrapped in their type, not checked. Thus, that example program actually looks like this, a statement list:</p><div class="language-ocaml"><button title="Copy Code" class="copy"></button><span class="lang">ocaml</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-light-text-decoration:underline;--shiki-dark:#F97583;--shiki-dark-text-decoration:underline;">let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#005CC5;--shiki-light-text-decoration:underline;--shiki-dark:#79B8FF;--shiki-dark-text-decoration:underline;"> x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> =</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-light-text-decoration:underline;--shiki-dark:#F97583;--shiki-dark-text-decoration:underline;">  let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> g</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-light-text-decoration:underline;--shiki-dark:#79B8FF;--shiki-dark-text-decoration:underline;">y</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> int) </span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> int </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-light-text-decoration:underline;--shiki-dark:#F97583;--shiki-dark-text-decoration:underline;">in</span><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;"> (* only ever here after calling f *)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  x</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-light-text-decoration:underline;--shiki-dark:#F97583;--shiki-dark-text-decoration:underline;">let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> h</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-light-text-decoration:underline;--shiki-dark:#79B8FF;--shiki-dark-text-decoration:underline;">x</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> int) </span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> int </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">=</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-light-text-decoration:underline;--shiki-dark:#F97583;--shiki-dark-text-decoration:underline;">  let</span><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;"> _</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> f x </span><span style="--shiki-light:#D73A49;--shiki-light-text-decoration:underline;--shiki-dark:#F97583;--shiki-dark-text-decoration:underline;">in</span><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;"> (* pulls the check of g into here *)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  x</span></span></code></pre></div><p>In fact, while we can actually do a dice roll and let the concolic evaluator pick which checker to run, we feel it is likely smarter to produce <code>n</code> separate target programs, each with a different checker, that can be run in parallel. The user can choose to run the checks in parallel this way with the <code>-p</code> flag to the <code>./ceval.exe</code> concolic evaluator executable.</p><h2 id="recursive-variants" tabindex="-1">Recursive variants <a class="header-anchor" href="#recursive-variants" aria-label="Permalink to “Recursive variants”">​</a></h2><p>The variant type embedding is a little bit confusing at first glance. Why do we partition the variant constructors into two cases?</p><p>We do this because the generation of some recursive variant types are unlikely to terminate if all variant constructors are equally likely to be picked. Imagine any AST type. Most cases split, and there are few leaves. Probabilistically, with no smart choices, the generation won&#39;t terminate.</p><p>This termination problem is solved by splitting the variants into those that are recursive and those that are not, and we make it extremely unlikely to pick a recursive variant. The concolic evaluator, however, doesn&#39;t care about &quot;unlikely&quot;; it can pick unlikely events with ease. Thus, these constructors are still easy to pick when they are wanted, and they are only hard to pick randomly. This encourages termination while still allowing exploration of the full program.</p><p>It is not included in the specification what happens if all constructors are recursive or all constructors are nonrecursive. We assume the reader understands that in either of these cases, the constructors are not partitioned at all, but rather they are joined under one case. This is handled in the implementation but is somewhat ignored in the spec. I think it is worthy of this comment here, however.</p>`,15)])])}const g=e(n,[["render",h]]);export{c as __pageData,g as default};
